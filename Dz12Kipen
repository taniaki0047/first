//умножение и сложение двух дробей 
#include <stdio.h>
typedef struct RATIONAL
 {
 	int b; unsigned a;
 }R;
 int inp(R *p)
 {
 	unsigned b; int a;
 	int n=scanf("%d %u", &a, &b);
 	p->a=a;p->b=b;
 	return n==2;
 }
 void out(const R *p) //const показывет, что значение не меняется 
 {
 	printf("%d/%u\n",p->a, p->b);
 }
 R add(R x, R y) //сложение 
 {
 	R z;
 	z.a=x.a*y.b+x.b*y.a; z.b=x.b*y.a;
 	reduce(&z);
 	return z;
 }
 R mult(R x, R y)//умножение 
 { R z; 
   z.a=x.a*y.a; z.b=x.b*y.b;
   reduce(&z);
   return z;
 }
 void comparison (R x, R y) //сравнение 
 {
 	unsigned a, b;
 	a=x.a*y.b; b=y.a*x.b; //printf("a %u b %u\n", a, b);
 	if(a>b)
 	{printf("1 chislo bolshe");}
 	if(a<b)
 	{printf("2 chislo bolshe");}
 	if(a==b)
 	{printf("Chisla ravny");}
 }
 void reduce(R *x) //сокращение 
 {
 	while(x->a%x->b!=0)
 	{
 		int z=x->b; 
 		x->b=x->a%x->b;
 		x->a=z;
 	}
 }
 int main()
 {
 	R x, y, z;
 	inp(&x); out(&x);
 	inp(&y); out(&y);
 	z=add(x, y); out(&z); comparison(x,y);
 }

//вывести вчерашнюю дату 
#include <stdio.h>
typedef struct DATE
{
	int d; int m; int y;
}DATE;
int inp(DATE *p); void out(const DATE *p); DATE yesterday(DATE *p);
int main()
{
	DATE k,l;
	inp(&k); out(&k);
	l=yesterday(&k); out(&l);
}
int inp(DATE *p)
{
	int d, m, y;
	int n=scanf("%d %d %d", &d, &m, &y);
	p->d=d; p->m=m; p->y=y;
	return n==3;
}
DATE yesterday(DATE *p)
{
	 DATE f;
	 int m[]={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
	 int m1[]={5, 7, 10, 12};
	 int m2[]={2, 4, 6, 9, 11};
	 for(int i=0;i<4;i++)
	 {
	 	if(p->m==m1[i]|p->d==1)
	    {f.d=30; f.m=p->m-1; f.y=p->y;}
	 }
	 for(int i=0;i<5;i++)
	 {
	 	if(p->d==1){f.d=31; f.m=p->m-1; f.y=p->y;}
	 }
	 for(int i=0;i<12;i++)
	 {
	 	if(p->d<=31|p->d>=2)
	 	{f.d=p->d-1; f.m=p->m; f.y=p->y;}
	 }
	 if(p->d==1|p->m==8)
	 {f.d=31; f.m=7; f.y=p->y;}
	 if(p->d==1|p->m==3)
	    {if(p->y%4==0){f.d=29;f.m=2;f.y=p->y;}
	 	else{f.d=28;f.m=2;f.y=p->y;}}
	 if(p->d==1|p->m==1)
	 	{f.d=31;f.m=12;f.y=p->y-1;}
	 return f;
}
void out(const DATE *p)
{
	printf("%d.%d.%d\n",p->d, p->m, p->y);
}

//структура полином, сложение, вычисление значения в данной точке, ввод и вывод 
#include <stdio.h>
#define N 100
typedef struct POLYNOM 
{
	int d; double c;
}P;
int inp(P a[N]);
void out(P a[N], int e);
int add( P a[N], P b[N], int t1, int t2, P c[N]);
double tochka(P a[N], int t1, double x);
int main()
{
	P p1[N], p2[N], p3[N];
	int t1, t2, t3;
	double x, z;
	printf("Vvedite znachenie tochki ");
	scanf("%lf", &x);
	t1=inp(p1); t2=inp(p2);
	t3=add(p1,p2,t1,t2,p3);
	out(p3, t3-1);
	z=tochka(p1, t1, x);
	printf("Znachenie mnogochlena v tochke x = %lf\n", z);
}
int inp(P a[N])
{
	int e;
	printf("Vvedite stepen ");
	scanf("%d", &e);
	printf("Vvedite coeficient nachinaya s 0 stepenya\n");
	for(int i=0;i<=e;i++)
	{
		printf("Coeficient ");
		scanf("%lf", &a[i].c);
		a[i].d=i;
	}
	return e;
}
void out(P a[N], int e)
{
	for(int k=0;k<e;k++)
	{
		printf("%lf(x^%d)+", a[k].c, a[k].d); 
	}
	printf("%lf(x^%d)", a[e].c, a[e].d);
}
int add( P a[N], P b[N], int t1, int t2, P c[N])
{
	int i=0, j=0, k=0;
	while(i<t1+1 && j<t2+1)
	{
		if(a[i].d==b[i].d)
		{
			c[k].c=a[i].c+b[i].c;
			c[k].d=a[i].d;
			i++; j++; k++;
		}
		else if(a[i].d>b[j].d)
		{
			c[k].c=a[i].c;
			c[k].d=a[i].d;
			i++; k++;
		}
		else
		{
			c[k].c=b[i].c;
			c[k].d=b[j].d;
			k++; j++;
		}
	}
	while(i<t1+1)
	{
		c[k].c=a[i].c;
		c[k].d=a[i].d;
		i++; k++;
	}
	while(j<t2+1)
	{
		c[k].c=b[j].c;
		c[k].d=b[j].d;
		k++; j++;
	}
	return k;
}
double tochka(P a[N], int t1, double x)
{
	double k=a[0].c;
	for(int i=1;i<=t1;i++)
	{
		k+=x*a[i].c;
	}
	return k;
}

/*Визначити типи запису для зображення таких понять адреса (мiсто, вулиця, будинок, квартира)*/
#include <stdio.h>
typedef struct ADRESS
{
	char *city; char *street; char *house; int apartment;
}ADRESS;
int input(ADRESS p)
{
	char *c, *s, *h; int a;
    printf("Vvedite adres ");
	int n=scanf("%s %s %s %d", &c, &s, &h, &a);
	p.city=c; p.apartment=a; p.house=h; p.street=s; 
	return n==4;
}
void output(const ADRESS p)
{
	printf("%s %s %s %d\n", p.city, p.street, p.house, p.apartment);
}
int main()
{
	ADRESS my;
	input(my); output(my);
}
